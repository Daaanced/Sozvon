Здесь будут изложены все мои заметки, мысли, идеи и задачи, над которыми стоит подумать в будущем.

(03.12.25)
Это мой первый серьезный проект. Я попытаюсь реализовать клиент-серверное приложения для общения. Приложение подобно Discord, со следующими возможностями:

1. Общения через чат (1 приоритет)
2. Голосового звонка (1 приоритет)
3. Трансляция своего экрана (2 приоритет)
4. Создание чатов и серверов (2 приоритет)
5. Включения веб-камеры (3 приоритет)

Думаю пригодится
*API (интерфейс прикладного программирования) — это набор правил и инструментов, который позволяет разным программам взаимодействовать друг с другом, обмениваясь данными.*

*Соответственно, API отвечает на вопрос “==Как ко мне, к моей системе можно обратиться==?”, и включает в себя:*  

- *саму операцию, которую мы можем выполнить,*
- *данные, которые поступают на вход,*
- *данные, которые оказываются на выходе (контент данных или сообщение об ошибке).*

API — это набор функций. Это может быть одна функция, а может быть много.

В моем представлении приложение состоит из 3 частей:
- Клиентская часть, состоящая из графического интерфейса и кучи методов, скрытых за интерфейсом. В свою очередь эти методы можно разделить на те, что воздействуют на клиент (интерфейс), и те, что взаимодействуют с сервером.  
- Серверная часть, API, работающее с потоками и сокетами.

(07.12.2025)
Необходимо узнать, как происходит передача голосового сигнала, какие ЯП подходят лучше всего для работы с сокетами и потоками, а именно поддерживаемые библиотеки и прочие инструменты.
# Сервер

==Язык для разработки сервера - Go==

Go имеет готовую библиотеку **Pion WebRTC**

Pion WebRTC позволяет легко перейти от P2P → к SFU

готовый WebRTC-стек: нет необходимости реализовывать RTP/STUN/TURN/ICE, SRTP

WebRTC идеально справляется с P2P: он автоматически решает ICE, STUN, NAT traversal, SRTP, DTLS, UDP и т. д.

Сервер: только сигнализация + STUN/TURN

Что делает сервер в P2P WebRTC?

Сервер выполняет **только сигнализацию**:

1. Сообщает пользователям, что есть звонок
    
2. Передает offer/answer
    
3. Передает ICE-кандидаты
    
4. Поддерживает список онлайн-пользователей
    
5. Иногда выполняет STUN/TURN

Теперь необходимо определиться как будет реализовано клиентское приложение и как оно будет взаимодействовать с сервером. 

Судя по информации ***chatgpt*** будем использовать 3 протокола:
## REST API для:

- регистрации
- логина
- поиска пользователей
- получение истории сообщений
## WebSocket для:

 - чата
- статусов онлайн
- инициирования звонков
- пересылки WebRTC offer/answer/ICE
- любых событий в реальном времени
## WebRTC для:

- аудио/видео P2P
- опционально data channel

# Клиент

Для клиента будет выбран Electron (JavaScript/TypeScript)
## Почему Electron:

- UI строится как обычный HTML/CSS/JS — проще не бывает.
- WebRTC встроен в Chromium → работает “из коробки”.
- WebSocket также встроен.
- Море библиотек, простота экосистемы.
- Удобная упаковка под Windows/Linux/macOS.
### Минусы:
- Большие размеры приложения (100–150 МБ).
- Требует минимальных знаний фронтенда — но самой базовой верстки вполне достаточно.

(18.12.2025)
Выяснил, что отдельный сервер для БД – не самая лучшая идея, а лучше создавать микросервисное приложение, где у каждого сервиса будет своя БД. А вопрос как именно функционирует сервер я оставлю на след день.
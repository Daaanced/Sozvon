Здесь будут изложены все мои заметки, мысли, идеи и задачи, над которыми стоит подумать в будущем.

(03.12.25)
Это мой первый серьезный проект. Я попытаюсь реализовать клиент-серверное приложения для общения. Приложение подобно Discord, со следующими возможностями:

1. Общения через чат (1 приоритет)
2. Голосового звонка (1 приоритет)
3. Трансляция своего экрана (2 приоритет)
4. Создание чатов и серверов (2 приоритет)
5. Включения веб-камеры (3 приоритет)

Думаю пригодится
*API (интерфейс прикладного программирования) — это набор правил и инструментов, который позволяет разным программам взаимодействовать друг с другом, обмениваясь данными.*

*Соответственно, API отвечает на вопрос “==Как ко мне, к моей системе можно обратиться==?”, и включает в себя:*  

- *саму операцию, которую мы можем выполнить,*
- *данные, которые поступают на вход,*
- *данные, которые оказываются на выходе (контент данных или сообщение об ошибке).*

API — это набор функций. Это может быть одна функция, а может быть много.

В моем представлении приложение состоит из 3 частей:
- Клиентская часть, состоящая из графического интерфейса и кучи методов, скрытых за интерфейсом. В свою очередь эти методы можно разделить на те, что воздействуют на клиент (интерфейс), и те, что взаимодействуют с сервером.  
- Серверная часть, API, работающее с потоками и сокетами.

(07.12.2025)
Необходимо узнать, как происходит передача голосового сигнала, какие ЯП подходят лучше всего для работы с сокетами и потоками, а именно поддерживаемые библиотеки и прочие инструменты.
# Сервер

==Язык для разработки сервера - Go==

Go имеет готовую библиотеку **Pion WebRTC**

Pion WebRTC позволяет легко перейти от P2P → к SFU

готовый WebRTC-стек: нет необходимости реализовывать RTP/STUN/TURN/ICE, SRTP

WebRTC идеально справляется с P2P: он автоматически решает ICE, STUN, NAT traversal, SRTP, DTLS, UDP и т. д.

Сервер: только сигнализация + STUN/TURN

Что делает сервер в P2P WebRTC?

Сервер выполняет **только сигнализацию**:

1. Сообщает пользователям, что есть звонок
    
2. Передает offer/answer
    
3. Передает ICE-кандидаты
    
4. Поддерживает список онлайн-пользователей
    
5. Иногда выполняет STUN/TURN

Теперь необходимо определиться как будет реализовано клиентское приложение и как оно будет взаимодействовать с сервером. 

Судя по информации ***chatgpt*** будем использовать 3 протокола:
## REST API для:

- регистрации
- логина
- поиска пользователей
- получение истории сообщений
## WebSocket для:

 - чата
- статусов онлайн
- инициирования звонков
- пересылки WebRTC offer/answer/ICE
- любых событий в реальном времени
## WebRTC для:

- аудио/видео P2P
- опционально data channel

# Клиент

Для клиента будет выбран Electron (JavaScript/TypeScript)
## Почему Electron:

- UI строится как обычный HTML/CSS/JS — проще не бывает.
- WebRTC встроен в Chromium → работает “из коробки”.
- WebSocket также встроен.
- Море библиотек, простота экосистемы.
- Удобная упаковка под Windows/Linux/macOS.
### Минусы:
- Большие размеры приложения (100–150 МБ).
- Требует минимальных знаний фронтенда — но самой базовой верстки вполне достаточно.

(18.12.2025)
Выяснил, что отдельный сервер для БД – не самая лучшая идея, а лучше создавать микросервисное приложение, где у каждого сервиса будет своя БД. А вопрос как именно функционирует сервер я оставлю на след день.

(28.01.2026)
2 недели назад я реализовал простейшие 3 микросервиса: 
	Gateway - точку входа, через которую будет работать клиент, и его запросы будут проксироваться на другие сервисы.
	Authtorization service -  принимает запрос клиента о создании новой учетной записи, в случае ошибки возвращает ответ. Также посылает запрос в User service, для создания профиля. (Также создает токен для работы?)
	User service - содержит личную информацию пользователя, а именно логин, имя, email, info, pic.
Во время создания приложения столкнулся с проблемой компиляции, chatGPT на первое время предложил отказаться от приложения в пользу обычного сайта, из-за чего столкнулся с CORS, из-за чего убил добрые 8 часов (если не все 10).
Проблема решилась топорно, проверив порты на открытость, оказалось что номер порта внешнего источника стоял 0 -- 0. Плюс к ответам сервера начало добавляться банальное "Access-Control-Allow-Origin". *Стоит переделать под расширение rs/cors*. 
P.S. дело определенно было в портах..

Сейчас буду делать боковое окошко с выводом недавних пользователей.

(11.02.2026)
Добавил Chat Service, вместе с ним БД с 3 таблицами:
	chats - хранит UID чата и время создания
	chat_members - связка UID чата-логина юзера, состоящего в этом чате
	messages - UID сообщения, UID чата, логин отправителя, текст сообщения, дата отправки
Пришел к MVP текстовому чату, где можно зарегистрироваться, найти собеседника по точному логину, написать ему сообщение, и он получит его в реальном времени.
Прежде чем приступать к реализации голосового чата, считаю необходимым:
	"Отполировать" текущий вариант - сделать рефакторинг, оптимизировать работу с сетью, кешируя данные
	Добавить функционал, свойственный мессенджерам: 
		Стилизовать окно чата - добавить справа карточку собеседника (имя, логин, картинка, статус), кнопку для голосового вызова
		Возможность отправлять картинки (отображение в чате, просмотр во "внутреннем редакторе", открытие полного изображеия по ссылке), файлы
		Поддержка гиперссылок
		Отображение состояния юзера - онлайн/офлайн

	Добавить окно настроек со следующим функционалом: возможность изменить фото, статус, имя, тему, покинуть и удалить аккаунт.
	Добавить возможность создания групп, до 9 человек.
	Добавить кнопку с общими комнатами, в которой будут голосовые чаты, к которым все имеют доступ